---
layout: post
title: 静态库、动态链接库
categories:
- c process
tags:
- c 语言
- 程序设计
---
# 使用程序库

## 静态库 

* 存档文件（ archive），也被称为静态库（ static library），是一个存储了多个对象文件（object file）的单一文件。（与 Windows 系统的 .LIB 文件基本相当。）

* ar 命令创建存档文件。传统上，存档文件使用 .a 后缀名，以便与 .o 的对象文件区分开。下面的命令可以将 test1.o 和 test2.o 合并成一个 libtest.a 

**`% ar cr libtest.a test1.o test2.o`**

上面的命令cr选项通知ar创建静态库。
传统上静态库使用.a后缀名，区别与.o对象文件

**你可以通过为gcc或g++指定 –ltest参数将程序链接到这个库，当连接器在命令行参数中获取到一个静态库文件时，它将在其中搜索被引用但未定义的符号的定义。定义了这些符号的文件将被提取，连接到新程序执行文件中。**

**通常将静态库当作参数放在命令行参数最后最有意义。**

## 例如test.c

	int f ()
	{
		return 3;
	}
	gcc -c test.c 
	ar cr libtest.a test.o 其他对象文件(xx.o)\
	int main ()
	{
		return f ();
	}
**在程序中使用静态连接库**

	gcc –o app app.o –L. –ltest


## 共享库

### 又叫动态链接库、共享对象

在某种程度上与由一组对象文件生成的打包文件相当类似。不过，两者之间的区别也是非常明显的。最本质的区别在于，当一个共享库被链接到程序中的时候，程序本身并不会包含共享库中出现的代码。

**程序仅包含一个对共享库的引用**

**第二个重要的区别在于，共享库不仅仅是对象文件的简单组合。当使用的时候，链接器会从中寻找需要的部分进行链接，以匹配未定义的符号引用。而当生成共享库的时候，所有对象文件被合成为一个单独的对象文件，从而使链接到这个库的程序总能包含库中的全部代码，而不仅仅是所需要的部分。
要创建一个共享库，你必须在编译那些用于生成共享库的对象时为编译器指定 –fPIC 选项。**

	gcc -c fPIC test.c

**这里的 –fPIC 选项会通知编译器你要将得到的 test1.o 作为共享库的一部分。然后你将得到的对象文件合并成一个共享库：**

	gcc –shared –fPIC –o libtest.so test1.o test2.o

>共享库通常使用.so作为后缀名。文件名以lib开头，这和静态库相同，在程序中使用共享库的方法也和静态库相同，

## 使用LD_LIBRARY_PAATH

> 当你将一个程序与共享库进行动态链接时，链接器不会将动态链接库的完整路径加入到执行文件中，而是只记录了动态链接库的名字，当程序实际运行时，系统会搜索并加载这个共享库默认情况下，系统会搜索并加载这个共享库，默认情况下，系统只搜索/lib/和/usr/lib。如果共享库的位置在这两者之外，系统将无法找到这个共享库。
一种解决方法是：在链接的时候指明-Wl,-rpath参数。假设你用下面的命令进行链接：

	gcc -o app app.c -L. -ltest -Wl,-rpath, /tmp/path

系统会在/tmp/path/目录下搜索所需库文件。（命令行参数的'-'切记是英文输入模式下的而非‘-’）

> 另一种解决方法是在运行程序时设置LD_LIBRARY_PATH环境变量。LD_LIBRARY_PATH环境变量是一组冒号分割的路径。程序运行时，系统会先搜索LD_LIBRARY_PATH所在路径
	
	gcc -o app app.c -L. -ltest
	LD_LIBRARY_PATH=/tmp/path
	export LD_LIBRARY_PAATH
	$ ./app 

ldd 程序名 显示与一个程序建立了动态链接的库的列表
